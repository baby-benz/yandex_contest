package ru.yandex.contest.houses_and_shops;

import java.util.Scanner;

/*
Эта задача может быть решена за квадратичное время поиском для каждого дома ближайших магазинов слева и справа.
Данный вариант решения предлагает обход за линейное время.
    1) Обозначим расстояние до ближайшего магазина как какое-то очень большое отрицательное число (мы будем это
       расстояние вычитать, поэтому знак инвертируется). В этом решении я использую минимальный int плюс количество
       зданий на улице, чтобы число было достаточно большим даже для задач большей размерности, но при этом в дальнейшем
       при работе с этим числом не возникло переполнения
    2) Для каждого дома найдем ближайший магазин слева. Для этого будем запоминать индекс магазина, если текущее здание -
       магазин, а при нахождении дома назначим ему расстояние до магазина как текущий индекс минус индекс магазина. Если
       первым зданием оказался дом, то, соответственно, расстояние до магазина будет равно тому большому числу, что мы
       ввели в 1) пункте
    3) Теперь найдем ближайшие магазины справа для каждого дома. Поскольку теперь мы будем наоборот вычитать из
       расстояния индекс, то инвертируем знак нашего очень большого числа. Integer.MIN_VALUE + кол-во зданий меняется на
       Integer.MAX_VALUE - кол-во зданий.
    4) Код внутри цикла практически такой же за исключением нескольких важных нюансов:
        а) Начинаем обход с конца массива, поскольку считаем расстояния справа
        б) Запоминать расстояния уже не требуется, вместо этого будем сравнивать найденное расстояние с тем, что уже
           находится в массиве. Найдем среди этих двух расстояний (слева и справа) минимум
        в) Задача сводится к максимизации минимумов или, другими словами, нахождении максимума среди расстояний от домов
           до ближайших магазинов, поэтому при нахождении дома сразу же будем сравнивать его расстояние с текущим
           максимумом (изначально максимум = 0)

    Сложность алгоритма - O(n), мы обходим массив зданий лишь дважды
*/

public class Main {
    public static void main(String[] args) {
        try (Scanner sc = new Scanner(System.in)) {
            int[] buildings = new int[10];

            for (int i = 0; i < 10; i++) {
                buildings[i] = sc.nextInt();
            }

            int curShopDist = Integer.MIN_VALUE + 10;
            int[] leftShopDists = new int[10];

            for (int i = 0; i < 10; i++) {
                if (buildings[i] == 2) {
                    curShopDist = i;
                } else if (buildings[i] == 1) {
                    leftShopDists[i] = i - curShopDist;
                }
            }

            curShopDist = Integer.MAX_VALUE - 10;

            int curMinDist;
            int maxDist = 0;

            for (int i = 9; i >= 0; i--) {
                if (buildings[i] == 2) {
                    curShopDist = i;
                } else if (buildings[i] == 1) {
                    curMinDist = Math.min(leftShopDists[i], curShopDist - i);
                    maxDist = Math.max(curMinDist, maxDist);
                }
            }

            System.out.println(maxDist);
        }
    }
}
